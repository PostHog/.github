# This workflow manages pull requests on project boards for the Feature Flags teams.
# It uses a team-to-board mapping (TEAM_BOARD_CONFIG) to route PRs to the correct boards.
# When a member of a mapped team is added as a reviewer to a PR, the workflow will:
# - Add the PR to that team's project board
# - Set the status of the PR to 'In Review'
# When a PR is converted to draft mode, the workflow will:
# - Set the status of the PR to 'In Progress'
# When a PR is marked ready for review, the workflow will:
# - Set the status of the PR to 'In Review'
# When changes are requested on a PR review, the workflow will:
# - Set the status of the PR to 'In Progress'
# A single PR can be added to multiple boards if reviewers from multiple teams are requested.
#
# Required GitHub App permissions:
# - PROJECT_BOARD_BOT_APP_ID and PROJECT_BOARD_BOT_PRIVATE_KEY secrets
# - App permissions needed:
#   - Repository: Pull requests (read)
#   - Organization: Projects (read & write)
#   - Organization: Members (read)

name: Add PR to Feature Flags Project

# Each entry maps a GitHub team to a project board. When a member of the team is
# requested as a reviewer, the PR is added to that team's board. The IDs require
# using the GraphQL API to retrieve.
env:
    ORG_NAME: PostHog
    TEAM_BOARD_CONFIG: |
        [
            {
                "team_slug": "team-feature-flags",
                "project_v2_id": "PVT_kwDOA5iQ-M4AroCF",
                "status_field_id": "PVTSSF_lADOA5iQ-M4AroCFzgirkuw",
                "in_review_option_id": "8d24d43c",
                "in_progress_option_id": "f75ad846"
            },
            {
                "team_slug": "team-flags-platform",
                "project_v2_id": "PVT_kwDOA5iQ-M4BPB59",
                "status_field_id": "PVTSSF_lADOA5iQ-M4BPB59zg9jxJs",
                "in_review_option_id": "df73e18b",
                "in_progress_option_id": "47fc9ee4"
            }
        ]

on:
    workflow_call:
        # 'workflow_call' means the workflow is called from another workflow via the uses: keyword
        # But the github.event_name is the original event name (e.g. pull_request) because this workflow 
        # lives in the special .github repository (It's a not well-documented special case).
        inputs:
            pr_number:
                description: 'The number of the pull request'
                required: true
                type: number
            pr_node_id:
                description: 'The node ID of the pull request'
                required: true
                type: string
            is_draft:
                description: 'Whether the pull request is in draft mode'
                required: true
                type: boolean
    pull_request_review:
        types: [submitted]
    workflow_dispatch:
        inputs:
            pr_number:
                description: 'The number of the pull request'
                required: true
                type: number
            repository:
                description: 'The repository name (e.g. todo-app)'
                required: true
                type: string

jobs:
    add-to-project-board:
        runs-on: ubuntu-latest
        # When the workflow is called via `workflow_call` (aka from another workflow via the uses: keyword), from another repository,
        # the github.event_name is supposed to be `workflow_call`, but because this workflow lives in the special `.github` repository,
        # it preserves the original event name (e.g. pull_request).
        # This is a not well-documented special case.
        if: github.event_name == 'workflow_dispatch' || github.event_name == 'pull_request' || github.event_name == 'pull_request_review'
        steps:
            - name: Generate GitHub App Token
              id: app-token
              uses: actions/create-github-app-token@v2
              with:
                  app-id: ${{ secrets.PROJECT_BOARD_BOT_APP_ID }}
                  private-key: ${{ secrets.PROJECT_BOARD_BOT_PRIVATE_KEY }}
                  owner: ${{ env.ORG_NAME }}
            - name: Get PR Node ID for workflow_dispatch
              id: get-pr
              if: github.event_name == 'workflow_dispatch'
              uses: actions/github-script@v7
              env:
                  PR_NUMBER: ${{ github.event.inputs.pr_number }}
                  REPO: ${{ github.event.inputs.repository }}
              with:
                  github-token: ${{ steps.app-token.outputs.token }}
                  script: |
                      const prNumber = "$PR_NUMBER";
                      const repo = "$REPO";
                      const owner = process.env.ORG_NAME;
                      
                      const { data: pr } = await github.rest.pulls.get({
                          owner,
                          repo,
                          pull_number: prNumber
                      });
                      
                      // Store the full PR data as a JSON string in the output
                      core.setOutput('pr_data', JSON.stringify(pr));
                      core.setOutput('node_id', pr.node_id);
                      core.setOutput('is_draft', pr.draft.toString());

            - name: Determine PR status and matching boards
              id: check
              uses: actions/github-script@v7
              env:
                  ORG_NAME: '${{ env.ORG_NAME }}'
                  PR_NODE_ID: ${{ inputs.pr_node_id }}
                  IS_DRAFT: ${{ inputs.is_draft }}
              with:
                  github-token: ${{ steps.app-token.outputs.token }}
                  script: |
                      core.info('Event type: ' + context.eventName);

                      const teamBoardConfig = JSON.parse(process.env.TEAM_BOARD_CONFIG);

                      let pr, isDraft, nodeId;

                      if (context.eventName === 'pull_request') {
                          pr = context.payload.pull_request;
                          isDraft = pr.draft;
                          nodeId = pr.node_id;
                      } else if (context.eventName === 'pull_request_review') {
                          pr = context.payload.pull_request;
                          isDraft = pr.draft;
                          nodeId = pr.node_id;
                      } else if (context.eventName === 'workflow_dispatch') {
                          const prData = JSON.parse('${{ steps.get-pr.outputs.pr_data }}');
                          pr = prData;
                          nodeId = '${{ steps.get-pr.outputs.node_id }}';
                          isDraft = '${{ steps.get-pr.outputs.is_draft }}' === 'true';
                      } else if (context.eventName === 'workflow_call') {
                          const query = `
                            query($nodeId: ID!) {
                              node(id: $nodeId) {
                                ... on PullRequest {
                                  id
                                  number
                                  isDraft
                                  repository {
                                    nameWithOwner
                                  }
                                  requestedReviewers(first: 100) {
                                    nodes {
                                      ... on User {
                                        login
                                      }
                                      ... on Team {
                                        slug
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          `;

                          nodeId = process.env.PR_NODE_ID;
                          const result = await github.graphql(query, { nodeId });
                          const prData = result.node;

                          if (!prData) {
                              throw new Error(`Could not find PR with node ID: ${nodeId}`);
                          }

                          const [owner, repo] = prData.repository.nameWithOwner.split('/');

                          pr = {
                              number: prData.number,
                              draft: prData.isDraft,
                              node_id: nodeId,
                              base: { repo: { name: repo } },
                              requested_reviewers: prData.requestedReviewers.nodes.filter(r => 'login' in r),
                              requested_teams: prData.requestedReviewers.nodes.filter(r => 'slug' in r)
                          };
                          isDraft = process.env.IS_DRAFT === 'true';
                      } else {
                          throw new Error(`Unsupported event type: ${context.eventName}`);
                      }

                      const owner = process.env.ORG_NAME;
                      const repo = pr.base.repo.name;
                      const prNumber = pr.number;

                      core.info(`Evaluating PR #${prNumber} (draft: ${isDraft})`);

                      const requestedTeams = pr.requested_teams || [];
                      const requestedReviewers = pr.requested_reviewers || [];

                      const matchingBoards = [];

                      for (const config of teamBoardConfig) {
                          const teamSlug = config.team_slug;
                          core.info(`Checking team '${teamSlug}'…`);

                          const isTeamRequested = requestedTeams.some(t => t.slug === teamSlug);
                          let isMemberRequested = false;

                          if (isTeamRequested) {
                              core.info(`'${teamSlug}' is requested as a reviewer`);
                          } else if (requestedReviewers.length > 0) {
                              core.info(`'${teamSlug}' is not requested directly. Checking if any reviewer is a member…`);
                              const { data: teamMembers } = await github.rest.teams.listMembersInOrg({
                                  org: owner,
                                  team_slug: teamSlug,
                                  per_page: 100
                              });
                              isMemberRequested = requestedReviewers.some(reviewer =>
                                  teamMembers.some(member => member.login === reviewer.login)
                              );
                          } else {
                              core.info(`No reviewers requested. Skipping team '${teamSlug}'.`);
                          }

                          if (isTeamRequested || isMemberRequested) {
                              let statusOptionId, statusName;

                              if (context.eventName === 'pull_request_review' && context.payload.review.state === 'changes_requested') {
                                  statusOptionId = config.in_progress_option_id;
                                  statusName = 'In Progress';
                                  core.info(`Changes requested on PR #${prNumber}. Setting status to '${statusName}' on '${teamSlug}' board.`);
                              } else {
                                  statusOptionId = isDraft ? config.in_progress_option_id : config.in_review_option_id;
                                  statusName = isDraft ? 'In Progress' : 'In Review';
                                  core.info(`${isDraft ? 'Draft ' : ''}PR #${prNumber} has a reviewer from '${teamSlug}'. Setting status to '${statusName}'.`);
                              }

                              matchingBoards.push({
                                  team_slug: teamSlug,
                                  project_v2_id: config.project_v2_id,
                                  status_field_id: config.status_field_id,
                                  status_option_id: statusOptionId
                              });
                          } else {
                              core.info(`PR #${prNumber} is not relevant to team '${teamSlug}'. Skipping.`);
                          }
                      }

                      core.info(`Matched ${matchingBoards.length} board(s).`);
                      core.setOutput('has_matches', (matchingBoards.length > 0).toString());
                      core.setOutput('matching_boards', JSON.stringify(matchingBoards));
                      core.setOutput('pr_node_id', nodeId);
            - name: Update Project Boards
              if: steps.check.outputs.has_matches == 'true'
              uses: actions/github-script@v7
              env:
                  MATCHING_BOARDS: '${{ steps.check.outputs.matching_boards }}'
                  PR_NODE_ID: ${{ steps.check.outputs.pr_node_id }}
              with:
                  github-token: ${{ steps.app-token.outputs.token }}
                  script: |
                      const matchingBoards = JSON.parse(process.env.MATCHING_BOARDS);
                      const contentId = process.env.PR_NODE_ID;

                      // Fetch PR details once for logging across all board updates
                      const prQuery = `
                        query($nodeId: ID!) {
                          node(id: $nodeId) {
                            ... on PullRequest {
                              id
                              number
                              title
                            }
                          }
                        }
                      `;

                      const prResult = await github.graphql(prQuery, { nodeId: contentId });
                      const prData = prResult.node;

                      if (!prData) {
                          throw new Error(`Could not find PR with node ID: ${contentId}`);
                      }

                      const errors = [];

                      for (const board of matchingBoards) {
                          const projectId = board.project_v2_id;
                          const fieldId = board.status_field_id;
                          const optionId = board.status_option_id;

                          try {
                              // Get project details to validate field and option IDs
                              const projectQuery = `
                                query($projectId: ID!) {
                                  node(id: $projectId) {
                                    ... on ProjectV2 {
                                      title
                                      fields(first: 10) {
                                        nodes {
                                          ... on ProjectV2SingleSelectField {
                                            id
                                            name
                                            options {
                                              id
                                              name
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              `;

                              const projectResult = await github.graphql(projectQuery, { projectId });
                              const project = projectResult.node;
                              const statusField = project.fields.nodes.find(f => f.id === fieldId);

                              if (!statusField) {
                                  throw new Error(`Could not find status field with ID ${fieldId} in project '${project.title}'.`);
                              }

                              const statusOption = statusField.options.find(o => o.id === optionId);

                              if (!statusOption) {
                                  throw new Error(`Could not find status option with ID ${optionId} in field '${statusField.name}'.`);
                              }

                              core.info(`Checking if PR #${prData.number} (${prData.title}) is already in project '${project.title}'…`);

                              // Unfortunately the GraphQL API doesn't allow filtering by content ID as part of the query.
                              const itemsQuery = `
                                query($projectId: ID!) {
                                  node(id: $projectId) {
                                    ... on ProjectV2 {
                                      items(first: 100) {
                                        nodes {
                                          id
                                          content {
                                            ... on PullRequest {
                                              id
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              `;

                              const result = await github.graphql(itemsQuery, { projectId });
                              const items = result.node.items.nodes;
                              let existingItemId = items.find(item => item.content?.id === contentId)?.id || null;

                              if (existingItemId) {
                                  core.info(`PR #${prData.number} (${prData.title}) already exists in project '${project.title}'. Updating status to '${statusOption.name}'…`);
                              } else {
                                  core.info(`Adding PR #${prData.number} (${prData.title}) to project '${project.title}'…`);
                                  const addItemMutation = `
                                    mutation($projectId: ID!, $contentId: ID!) {
                                      addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                                        item {
                                          id
                                        }
                                      }
                                    }
                                  `;

                                  const response = await github.graphql(addItemMutation, { projectId, contentId });
                                  existingItemId = response.addProjectV2ItemById.item.id;
                                  core.info(`Added PR #${prData.number} (${prData.title}) to project '${project.title}'.`);
                              }

                              const updateStatusMutation = `
                                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                                  updateProjectV2ItemFieldValue(input: {
                                    projectId: $projectId,
                                    itemId: $itemId,
                                    fieldId: $fieldId,
                                    value: { singleSelectOptionId: $optionId }
                                  }) {
                                    projectV2Item {
                                      id
                                    }
                                  }
                                }
                              `;

                              await github.graphql(updateStatusMutation, {
                                  projectId,
                                  itemId: existingItemId,
                                  fieldId,
                                  optionId
                              });
                              core.info(`Updated PR #${prData.number} (${prData.title}) status to '${statusOption.name}' in project '${project.title}'.`);
                          } catch (error) {
                              const msg = `Failed to update board for team '${board.team_slug}': ${error.message}`;
                              core.error(msg);
                              errors.push(msg);
                          }
                      }

                      if (errors.length > 0) {
                          core.setFailed(`${errors.length} board update(s) failed:\n${errors.join('\n')}`);
                      }
